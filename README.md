## ИДЕЙНО В ЧЕМ ЛАБА

Надо написать систему для взлома md5-хеша.

Есть: клиент, менеджер и воркеры.

Клиент отправляет запрос на менеджера. В запросе указан хеш какого-то слова (его не знает никто, ни клиент, ни менеджер, ни воркеры) и предполагаемую максимальную длину этого слова. Т.е. может оказаться так, что например, быол загадано слова длины 5, а клиент ограничил макс.длину до 3. Тогда слово не найдется. Еще может оказаться так, что на один и тот же хеш - может быть загадано несколько слов (учитывать это в программе + не обрывать поиск, если найдено 1 слово, тк их может быть несколько).

После того, как клиент отправил запрос, менеджер его получил, менеджер отправляет клиенту `id` запроса клиента (т.е. не ждет, когда же менеджер разделит задачи воркерам).

Итак, менеджер отправил клиенту `id` его запроса. Что он делает дальше?
Он делит все пространство перестановок на части и распределяет их между воркерами.
Подробнее про это.

У нас есть алфавит: `abcdefghijklmnopqrstuvwxyz0123456789` - в нем 36 символов.
Тогда если максимальная длина слова = 1, то сколько перестановок всего существует? Ответ: 36.
А если макс.длина = 2, то тогда сколько? Ответ: 36 + 36 * 36.
А если макс.длина = 3, то тогда сколько? Ответ: 36 + 36 * 36 + 36 * 36 * 36 и т.д.

| максимальная длина   | общее число перестановок   |
| :--------------:     | -----------------------    |
| 1                    | 36                         |
| 2                    | 1332                       |
| 3                    | 47988                      |
| 4                    | 1727604                    |
| 5                    | 62193780                   |
| 6                    | 2238976116                 |
| 7                    | 80603140212                |
| 8                    | 2901713047668              |
| 9                    | 104461669716084            |
| 10                   | 3760620109779060           |
| ...                  | ...                        |

Т.е. если макс.длина слова = n, то всего перестановок `T` = сумма (36 ^ n), где `n = {0, ..., max_length}`. И общее число перестановок (`T`) менеджер должен поделить между существующими воркерами наиболее оптимальным способом. Т.е.
1) чтобы все воркеры работали, не было такого, что воркеров 8, а из них работает лишь 2, при том что перестановок много.
2) чтобы не было такого, что общее число перестановок = 47988, воркеров пусть будет 8, и каждый воркер генерит по 10 слов)). Это плохо.
Т.е. надо сделать так, чтоб у каждого живущего воркера была как минимум 1 задача, которую он должен решить. Кол-во задач НЕ РАВНО кол-ву воркеров, это не круто, не оптимально. Кол-во задач БОЛЬШЕ ЛИБО РАВНО числу воркеров. И я решила проблемку оптимального разделения задач через логарифм (крч смотрим метод `determinePartNumber()` в `TaskDistributorService`).

А ну и еще. У меня `partNumber` - это кол-во задач, на которые разбивается все число перестановок (как раз то, что определяется в метде `determinePartNumber`). А partCount у меня - это количество элементов в задаче. `partNumber = const`, `partCount != const`.
Т.е. грубо говоря, например `T` = 1332, `workers_amount` = 8, тогда
1332 / 8 = 166.5 = 166. Получается что 7 воркеров из 8 будут генерить 166 слов, а 1 воркер - 166+остатки, т.е. 1332 - 166 * 7 = 1332 - 1162 = 170.

Так ну вот, менеджер нагенерил задачи. У меня сделано так, что как только менеджер сформировал задачу, он сразу отправляет ее свободному воркеру, т.е. не ждет того момента, когда сформирует все задачи и только потом начнет отправлять.

Для отправки задачи воркеру, ему необходимо еще сказать индекс, с которого ему надо считать (тк `partNumber` и `partCount` будет недостаточно для этого). У меня это `startIndex`. Ну и чтоб было (но уже необязательно), отправляю еще `endIndex`.

Воркер получил задачу, нагенерил слова, которые хеш которых должен посчитать и сравнить с тем хешем, который пришел от клиента. Если хеш совпал, то круто - отправляет найденное слово менеджеру. Если нет - то тож отправляет результат (ну да, пустой))).


## ПОЛЕЗНЫЕ ССЫЛКИ

- [видос про основы rabbitmq](https://www.youtube.com/watch?v=i-Eh-NCa0Tk)
- [статья про rabbitmq](https://habr.com/ru/companies/slurm/articles/704208/)
- [статья про direct exchange](https://astrio.ru/blog/rabbitmq-system/#:~:text=Direct%20Exchange%3A,Queue%202)
- [про rabbbit](https://blog.skillfactory.ru/rabbitmq-chto-eto-takoe-i-kak-rabotaet/)
- [про acknowledgments в rabbit](https://www.baeldung.com/rabbitmq-consumer-acknowledgments-publisher-confirmations)
- [статья RabbitMQ: терминология и базовые сущности](https://habr.com/ru/companies/slurm/articles/703060/)
- [про exchanges в rabbit](https://habr.com/ru/articles/489086/)
- [про AMQ статья](http://onreader.mdl.ru/RabbitMQInDepth/content/Ch02.html)
